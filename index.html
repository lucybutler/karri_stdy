<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Karri Study</title>
    <meta charset="utf-8" />

    <!-- jsPsych 6.1.0 core + plugins -->
  <script src="jspsych-6.1.0/jspsych.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-html-button-response.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-call-function.js"></script>
    <link rel="stylesheet" href="jspsych-6.1.0/css/jspsych.css">

    <style>
  :root { --size: 820px; --white-margin: 200px; --red-diameter: calc(var(--size) - var(--white-margin)); --band: calc(var(--red-diameter) / 6); --orange-band: var(--band); --green-band: var(--band); }
    html, body { background:#fff; color:#000; margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
      #jspsych-target { display:grid; place-items:center; min-height:100vh; }

      .wrap { display:flex; gap:24px; align-items:flex-start; padding:16px; }
      /* Circular board */
    .board { position:relative; width:var(--size); height:var(--size); background:#fff; border-radius:50%; display:grid; place-items:center; overflow:visible; }
  .ring { position:absolute; border-radius:50%; left:50%; top:50%; transform:translate(-50%,-50%); }
  .ring.red    { background:#c21f1f; width:var(--red-diameter); height:var(--red-diameter); z-index:1; }
  .ring.orange { background:#ff7a21; width:calc(var(--red-diameter) - (2 * var(--orange-band))); height:calc(var(--red-diameter) - (2 * var(--orange-band))); }
  .ring.orange { background:#ff7a21; width:calc(var(--red-diameter) - (2 * var(--orange-band))); height:calc(var(--red-diameter) - (2 * var(--orange-band))); z-index:1; }
  .ring.green  { background:#1aaa1a; width:calc(var(--red-diameter) - (2 * var(--orange-band)) - (2 * var(--green-band))); height:calc(var(--red-diameter) - (2 * var(--orange-band)) - (2 * var(--green-band))); z-index:1; }
  .center { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:calc(var(--red-diameter) - (6 * var(--band))); height:calc(var(--red-diameter) - (6 * var(--band))); border-radius:50%; background:var(--board-bg, #fff); z-index:1; }

  /* help button that sits inside the colored rings */
  .kc-ring-help { position:absolute; width:44px; height:44px; border-radius:50%; background:rgba(255,255,255,0.95); border:2px solid rgba(0,0,0,0.08); display:flex; align-items:center; justify-content:center; font-weight:700; font-size:20px; cursor:pointer; z-index:100000; box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
  .kc-ring-help.kc-help-red    { color:#c21f1f; }
  .kc-ring-help.kc-help-orange { color:#ff7a21; }
  .kc-ring-help.kc-help-green  { color:#1aaa1a; }

      .start-strip { width:220px; }
      .start-strip h3 { margin:.2rem 0 .6rem; font-weight:600; }
  .tiles { display:flex; flex-wrap:wrap; gap:8px; max-height:calc(var(--size) - 20px); overflow:auto; }
  .tile { width:110px; height:110px; border-radius:14px; background:transparent; display:flex; align-items:center; justify-content:center; }
  .tile { cursor:grab; touch-action:none; }
  .tile img { width:100%; height:100%; object-fit:contain; border-radius:12px; pointer-events:none; border:0; outline:0; }
  .ring { pointer-events:none; }
  /* larger text for item labels (when images are not used) */
  .tile { font-size: 26px; font-weight:700; }
  /* make tooltip text bigger for readability */
  .kc-tooltip { font-size: 18px; padding:8px 10px; }
  /* increase legend font-size slightly */
  .legend { font-size: 1.2rem; }
  /* We use the mouse-following tooltip (kc-tooltip) instead of CSS overlays */
  /* Make the mouse-following tooltip larger and more readable */
  .kc-tooltip { font-size: 20px; padding:10px 12px; }
  .ring.active { filter: brightness(1.25); box-shadow: 0 0 18px rgba(0,0,0,0.25) inset; }

      .legend { font-size:.9rem; opacity:.85; line-height:1.4; margin-top:.75rem; }
      .legend div { margin-bottom:6px; display:flex; align-items:center; gap:8px; }
      .swatch { width:16px; height:16px; border-radius:50%; display:inline-block; }

      /* Draggables that live on the board */
      .item { position:absolute; width:110px; height:110px; border-radius:14px; background:transparent; display:flex; align-items:center; justify-content:center; cursor:grab; user-select:none; }
        .item.dragging { opacity:.85; cursor:grabbing; }
      .item img { width:100%; height:100%; object-fit:contain; border-radius:12px; border:0; outline:0; }
      /* bring placed items above rings and other page content */
      .item { z-index:300000; }
      /* ensure tiles themselves are positioned so label z-index works */
      .tile { position: relative; z-index:300001; }
      .tile-label { position: absolute; left: 6px; right: 6px; bottom: 6px; text-align: center; pointer-events: none; z-index: 300002; font-size: 18px; font-weight:700; color: #000; background: rgba(255,255,255,0.85); border-radius:6px; padding:4px 6px; }

  /* tooltip bubble */
  .kc-tooltip { position:fixed; pointer-events:none; background:rgba(0,0,0,0.85); color:#fff; padding:6px 8px; border-radius:6px; font-size:13px; z-index:100000; transform:translate(8px,8px); }

  /* placeholder to keep start tile positions stable when items are picked up */
  .tile-placeholder { width:110px; height:110px; display:inline-block; vertical-align:top; border-radius:14px; background:transparent; }

      /* Make the default jsPsych button green */
      .jspsych-btn { background:#28a745; color:#fff; border-radius:8px; border: none; padding: 12px 18px; font-size:18px; min-width:140px; cursor:pointer; }
  .jspsych-content { color:#000; }
      /* special green continue button used on final screen */
      .kc-continue-btn { background: #28a745 !important; color: #fff !important; border: none; }
    </style>
  </head>
  <body>
    <!-- Configure remote collector: set these values after deploying your Apps Script web app -->
    <script>
      // Replace the endpoint below with your deployed Apps Script Web App URL (or other collector)
      // Example: 'https://script.google.com/macros/s/AKfycbx.../exec'
      window.KC_REMOTE_ENDPOINT = window.KC_REMOTE_ENDPOINT || 'https://script.google.com/macros/s/AKfycby3wMsgKERI28rn8mVR6vtZCKie7GLllEnsR2pI3xhgJ2LdKfD6SRqsBeG71OV3nStw/exec';

      // Replace with the shared secret you set in the Apps Script EXPECTED_SECRET.
      // WARNING: putting the secret here makes it public in the site source. Use only as a light anti-spam.
      window.KC_REMOTE_SECRET = window.KC_REMOTE_SECRET || 'TESTER';
    </script>

    <div id="jspsych-target"></div>

    <script>
      // ======= GLOBALS / CONFIG =======
      var timeline = [];

    // Your images (folder: img/)
    var ITEMS = [
      { id:'kangaroo',   label:'kangaroo',   img:'img/kangaroo.png' },
      { id:'city',       label:'city',       img:'img/city.png' },
      { id:'family',     label:'family',     img:'img/family.png' },
      { id:'forest',     label:'forest',     img:'img/forest.png' },
      { id:'friends',    label:'friends',    img:'img/friends.png' },
      { id:'giraffe',    label:'giraffe',    img:'img/giraffe.png' },
      { id:'karak',      label:'karak',      img:'img/karak.png' },
      { id:'park',       label:'park',       img:'img/park.png' },
      { id:'pets',       label:'pets',       img:'img/pets.png' },
      { id:'quenda',     label:'quenda',     img:'img/quenda.png' },
      { id:'shoes',      label:'shoes',      img:'img/shoes.png' },
      { id:'table',      label:'table',      img:'img/table.png' },
      { id:'tiger',      label:'tiger',      img:'img/tiger.png' },
      { id:'tree',       label:'tree',       img:'img/tree.png' },
      { id:'woodpecker', label:'woodpecker', img:'img/woodpecker.png' }
    ];

    // Must mirror CSS custom properties
  var BOARD_SIZE   = 820;  // px (diameter)
    var WHITE_MARGIN = 200;   // outer white band width (px)
    // per-item scores (initialized to 0)
    var SCORES = {};
    ITEMS.forEach(function(it){ SCORES[it.id] = 0; });
    // also expose per-item globals like `petsScore`, `shoesScore`, etc.
    ITEMS.forEach(function(it){
      try { window[it.id + 'Score'] = 0; } catch (e) { /* ignore non-browser env */ }
    });

    function setItemScore(itemId, score) {
      if (!(itemId in SCORES)) SCORES[itemId] = 0;
      SCORES[itemId] = score;
      // update the named global variable as well (e.g. petsScore)
      try { window[itemId + 'Score'] = score; } catch (e) { /* ignore */ }
    }

    function getItemScore(itemId) {
      return (itemId in SCORES) ? SCORES[itemId] : 0;
    }
    // Read ring thickness from CSS variables so detection matches visuals
    function cssPxVar(name, fallback) {
      var val = getComputedStyle(document.documentElement).getPropertyValue(name);
      if (!val) return fallback;
      return parseFloat(val);
    }
  // Read band widths (these are radial band thicknesses in px)
  var ORANGE_BAND = cssPxVar('--orange-band', 120);
  var GREEN_BAND  = cssPxVar('--green-band', 24);
  // compute detection radii dynamically from the actual ring elements so visuals and hit detection match
  function computeRadii(boardEl) {
    boardEl = boardEl || document.getElementById('board');
    var red = boardEl.querySelector('.ring.red');
    var orange = boardEl.querySelector('.ring.orange');
    var green = boardEl.querySelector('.ring.green');
    if (red && orange && green) {
      var rRed = red.getBoundingClientRect().width / 2;
      var rOrange = orange.getBoundingClientRect().width / 2;
      var rGreen = green.getBoundingClientRect().width / 2;
      return { rRed: rRed, rOrange: rOrange, rGreen: rGreen };
    }
    // fallback to CSS-vars/math
    var redDiameter = cssPxVar('--red-diameter', BOARD_SIZE - WHITE_MARGIN);
    var band = cssPxVar('--band', (redDiameter/6));
    var rRed = redDiameter / 2;
    var rOrange = rRed - band;
    var rGreen  = rOrange - band;
    return { rRed: rRed, rOrange: rOrange, rGreen: rGreen };
  }

    // ======= HELPERS =======
    function showError(msg) {
      try {
        var target = document.getElementById('jspsych-target') || document.body;
        var box = document.getElementById('kc-error-box');
        if (!box) {
          box = document.createElement('div');
          box.id = 'kc-error-box';
          box.style.position = 'fixed';
          box.style.left = '12px';
          box.style.right = '12px';
          box.style.top = '12px';
          box.style.background = '#ffecec';
          box.style.border = '1px solid #ffb5b5';
          box.style.padding = '10px';
          box.style.zIndex = 99999;
          box.style.maxHeight = '40vh';
          box.style.overflow = 'auto';
          target.appendChild(box);
        }
        var p = document.createElement('pre'); p.style.margin = '0'; p.textContent = msg;
        box.appendChild(p);
      } catch (e) { console.error('showError failed', e); }
    }

    // global error handler to surface exceptions during the experiment
    window.addEventListener('error', function(ev){
      console.error('Global error', ev.error || ev.message, ev);
      try { showError('Error: ' + (ev.error && ev.error.message ? ev.error.message : ev.message)); } catch(e){}
    });
    function boardHTML () {
      // Wrap the board and start-strip in a centered container to match the
      // instructions page width (max-width:820px) so both screens align visually.
      return '' +
        '<div style="max-width:820px;margin:0 auto;padding:8px">' +
          '<div class="wrap">' +
            '<div class="board" id="board" style="width:'+BOARD_SIZE+'px;height:'+BOARD_SIZE+'px;">' +
              '<div class="ring red"></div>' +
              '<div class="ring orange"></div>' +
              '<div class="ring green"></div>' +
              '<div class="center"></div>' +
              // question-mark help controls (positioned via JS)
              '<div id="kc-red-help" class="kc-ring-help kc-help-red" title="Play red instructions">?</div>' +
              '<div id="kc-orange-help" class="kc-ring-help kc-help-orange" title="Play orange instructions">?</div>' +
              '<div id="kc-green-help" class="kc-ring-help kc-help-green" title="Play green instructions">?</div>' +
              // hidden audio elements for instructions
              '<audio id="kc-red-audio" preload="auto" style="display:none"><source src="mp3/red_instructions.mp3" type="audio/mp3"></audio>' +
              '<audio id="kc-orange-audio" preload="auto" style="display:none"><source src="mp3/orange_instructions.mp3" type="audio/mp3"></audio>' +
              '<audio id="kc-green-audio" preload="auto" style="display:none"><source src="mp3/green_instructions.mp3" type="audio/mp3"></audio>' +
            '</div>' +
            '<div class="start-strip">' +
                '<div class="tiles" id="startTiles"></div>' +
              '<div class="legend">' +
                '</div>' +
            '</div>' +
          '</div>' +
        '</div>';
    }

    // Generic helper to position a help control for a given band and attach playback
  function setupRingHelpControl(helpId, audioId, bandOuterRadiusName, bandInnerRadiusName, angleRadians, yOffsetPixels) {
      try {
        var board = document.getElementById('board');
        if (!board) return;
        var help = document.getElementById(helpId);
        var audio = document.getElementById(audioId);
        var radii = computeRadii(board) || {};
        var boardRect = board.getBoundingClientRect();
        var cx = boardRect.width / 2;
        var cy = boardRect.height / 2;
        var rOuter = radii[bandOuterRadiusName] || (Math.min(boardRect.width, boardRect.height) / 2);
        var rInner = radii[bandInnerRadiusName] || (rOuter - (ORANGE_BAND || 0));
        var placementRadius = (rOuter + rInner) / 2;
        var angle = (typeof angleRadians === 'number') ? angleRadians : -Math.PI/2;
        if (help) {
          var hw = help.offsetWidth || 44;
          var hh = help.offsetHeight || 44;
          var left = cx + (placementRadius * Math.cos(angle)) - (hw/2);
          var top  = cy + (placementRadius * Math.sin(angle)) - (hh/2);
          if (typeof yOffsetPixels === 'number' && yOffsetPixels !== 0) top = top + yOffsetPixels;
          help.style.left = Math.round(left) + 'px';
          help.style.top  = Math.round(top) + 'px';
        }
        if (help && audio) {
          // ensure click plays the correct audio; fall back to Audio API on failure
          help.addEventListener('click', function(){
            try {
              var p = audio.play();
              if (p && p.then) p.catch(function(){ try { new Audio(audio.querySelector('source').src).play(); } catch(e){} });
            } catch (e) { try { new Audio(audio.querySelector('source').src).play(); } catch(e){} }
          });
        }
      } catch (e) { console.error('setupRingHelpControl failed for', helpId, e); }
    }

    // Convenience calls to set up each ring control (angles in radians)
    function setupAllRingHelpControls() {
      // place all controls along the same vertical line (top direction, -90deg)
      setupRingHelpControl('kc-red-help', 'kc-red-audio', 'rRed', 'rOrange', -Math.PI/2);
      setupRingHelpControl('kc-orange-help', 'kc-orange-audio', 'rOrange', 'rGreen', -Math.PI/2);
      // nudge the green control down further to avoid overlap
      setupRingHelpControl('kc-green-help', 'kc-green-audio', 'rGreen', 'rGreen', -Math.PI/2, 40);
    }

    function placeStartTiles () {
      var board = document.getElementById('board');
      if (!board) return;
      // clear any existing placeholders that might have been created previously
      var existing = board.querySelectorAll('.tile-placeholder');
      existing.forEach(function(el){ try { el.parentNode.removeChild(el); } catch(e){} });

      // compute geometry
      var boardRect = board.getBoundingClientRect();
      var boardW = boardRect.width || BOARD_SIZE;
      var boardH = boardRect.height || BOARD_SIZE;
      var cx = boardW / 2;
      var cy = boardH / 2;
      var radii = computeRadii(board);
      var rRed = radii && radii.rRed ? radii.rRed : ((Math.min(boardW, boardH) - WHITE_MARGIN)/2);
      var boardRadius = Math.min(boardW, boardH) / 2;
      // place tiles midway between red ring and board edge (the white band)
  var tileW = 110, tileH = 110;
  var tileRadius = Math.max(tileW, tileH) / 2.5;
  // place placeholders at a fixed offset outside the red ring so their
  // relative position doesn't shift when ring sizes or CSS variables change.
  var OFFSET_FROM_RED = 160 // px between red ring edge and the outside of the tile (increased to push tiles further out)
  // Compute placement radius so tiles sit in the white band (outside red ring)
  var maxR = boardRadius - tileRadius - 4; // keep tiles inside board edge
  var minR = rRed + tileRadius + 8; // ensure tile's outer edge is at least 8px outside red ring
  // Prefer a point part-way through the white band (60% out from red to outer edge)
  var preferR = rRed + (boardRadius - rRed) * 0.6;
  var placementRadius = Math.max(minR, Math.min(preferR, maxR));
  var n = ITEMS.length;
      var angleStep = (Math.PI * 2) / n;

  ITEMS.forEach(function (it, i) {
    var angle = -Math.PI/2 + (i * angleStep); // start at top and go clockwise
  var tileW = 110, tileH = 110;
    var left = cx + (placementRadius * Math.cos(angle)) - (tileW/2);
    var top  = cy + (placementRadius * Math.sin(angle)) - (tileH/2);

        var placeholder = document.createElement('div');
        placeholder.className = 'tile-placeholder';
        placeholder.id = 'ph-' + it.id;
        // position the placeholder inside the side start-strip if present
        placeholder.style.width = tileW + 'px';
        placeholder.style.height = tileH + 'px';
        placeholder.style.pointerEvents = 'auto';
        // absolute-position the placeholder around the board in a circle
        placeholder.style.position = 'absolute';
        placeholder.style.left = Math.round(left) + 'px';
        placeholder.style.top = Math.round(top) + 'px';
        placeholder.style.zIndex = 200001; // ensure placeholders sit above rings
        board.appendChild(placeholder);

        var t = document.createElement('div');
  t.className = 'tile';
  t.id = 'tile-' + it.id;
  t.setAttribute('data-id', it.id);
        if (it.img) {
          var im = document.createElement('img');
          im.src = it.img; im.alt = it.label; im.draggable = false; t.appendChild(im);
          // if there is also a label, show it as a small overlay label
          var lbl = document.createElement('div'); lbl.className = 'tile-label'; lbl.textContent = it.label; t.appendChild(lbl);
        } else {
          // text-only tiles: wrap label in a span so we can control z-index and styling
          var lbl = document.createElement('div'); lbl.className = 'tile-label'; lbl.textContent = it.label; t.appendChild(lbl);
        }
        t.style.touchAction = 'none';

        placeholder.appendChild(t);
        board.appendChild(placeholder);
        enableDrag(t, board);
        attachTooltip(t, it.label);
      });
      // ensure the ring help controls are positioned and wired up
      try { setTimeout(setupAllRingHelpControls, 20); } catch(e){}
    }

    // tooltip element (singleton)
    var kc_tooltip = null;
    function ensureTooltip(){
      if (kc_tooltip) return kc_tooltip;
      kc_tooltip = document.createElement('div'); kc_tooltip.className = 'kc-tooltip'; kc_tooltip.style.display = 'none';
      // ensure the tooltip is large and readable even if CSS is overridden
      kc_tooltip.style.fontSize = '22px';
      kc_tooltip.style.padding = '10px 12px';
      kc_tooltip.style.lineHeight = '1.2';
      kc_tooltip.style.borderRadius = '8px';
      kc_tooltip.style.background = 'rgba(0,0,0,0.85)';
      kc_tooltip.style.color = '#fff';
      kc_tooltip.style.zIndex = 100000;
      document.body.appendChild(kc_tooltip);
      return kc_tooltip;
    }
    function showTooltip(text, x, y){
      var t = ensureTooltip(); t.textContent = text; t.style.left = (x+8) + 'px'; t.style.top = (y+8) + 'px'; t.style.display = 'block';
    }
    function moveTooltip(x,y){ if (!kc_tooltip) return; kc_tooltip.style.left = (x+8) + 'px'; kc_tooltip.style.top = (y+8) + 'px'; }
    function hideTooltip(){ if (!kc_tooltip) return; kc_tooltip.style.display = 'none'; }

    function attachTooltip(el, text){
      el.addEventListener('pointerenter', function(e){ try { showTooltip(text, e.clientX, e.clientY); } catch(ex){} });
      el.addEventListener('pointermove', function(e){ try { moveTooltip(e.clientX, e.clientY); } catch(ex){} });
      el.addEventListener('pointerleave', function(e){ try { hideTooltip(); } catch(ex){} });
    }

    // placeDraggables removed: start tiles are the draggable elements now

    function enableDrag (el, board) {
      var ox=0, oy=0, dragging=false;
      var original = {};
      var dragEl = null; // the element that will follow the pointer (we use the original)

      function clearRingHighlights() {
        var rings = board.querySelectorAll('.ring');
        rings.forEach(function(r){ r.classList.remove('active'); });
      }

      function down (e) {
        var p = e.touches ? e.touches[0] : e;
        dragging = true; el.classList.add('dragging');
        e.preventDefault();

        clearRingHighlights();

  // save original placeholder so we can restore if dropped outside
  original.placeholder = document.getElementById('ph-' + (el.getAttribute('data-id') || el.id.replace(/^tile-/, '')));
  original.parent = original.placeholder;
  original.id = el.id;

        var elRect = el.getBoundingClientRect();
        ox = p.clientX - elRect.left; oy = p.clientY - elRect.top;

        // move the ORIGINAL into the document body and make it fixed-position so it follows the pointer
        try {
          // size it to keep visual layout stable
          el.style.width = elRect.width + 'px';
          el.style.height = elRect.height + 'px';
          el.style.position = 'fixed';
          el.style.left = (p.clientX - ox) + 'px';
          el.style.top = (p.clientY - oy) + 'px';
          el.style.zIndex = 99999;
          el.style.pointerEvents = 'none';
          // detach from placeholder and move to body so it can follow pointer
          try { if (original.parent && original.parent.contains(el)) original.parent.removeChild(el); } catch(e){}
          document.body.appendChild(el);
          dragEl = el;
        } catch (err) { console.error('move-on-pickup failed', err); }

        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', up, { once:true });
      }

      function move (e) {
        if (!dragging || !dragEl) return;
        var p = e.touches ? e.touches[0] : e;
        dragEl.style.left = (p.clientX - ox) + 'px';
        dragEl.style.top  = (p.clientY - oy) + 'px';

        // hover highlight: compute clone center and highlight the ring under it
        var boardRect = board.getBoundingClientRect();
        var elRect = dragEl.getBoundingClientRect();
        var centerX = elRect.left + elRect.width/2;
        var centerY = elRect.top + elRect.height/2;
        var cx = boardRect.left + boardRect.width/2;
        var cy = boardRect.top + boardRect.height/2;
        var dx = centerX - cx, dy = centerY - cy;
        var dist = Math.sqrt(dx*dx + dy*dy);

        var radii = computeRadii(board);
        clearRingHighlights();
        if (dist <= radii.rGreen)  { var ring = board.querySelector('.ring.green'); if (ring) ring.classList.add('active'); }
        else if (dist <= radii.rOrange) { var ring = board.querySelector('.ring.orange'); if (ring) ring.classList.add('active'); }
        else if (dist <= radii.rRed) { var ring = board.querySelector('.ring.red'); if (ring) ring.classList.add('active'); }
      }

      function up (e) {
        dragging = false;
        window.removeEventListener('pointermove', move);

        if (!dragEl) return;
        var p = e.changedTouches ? e.changedTouches[0] : e;
        var boardRect = board.getBoundingClientRect();

        // Use the center of the dragged element for ring detection
        var elRect = dragEl.getBoundingClientRect();
        var centerX = elRect.left + elRect.width/2;
        var centerY = elRect.top + elRect.height/2;
        var cx = boardRect.left + boardRect.width/2;
        var cy = boardRect.top + boardRect.height/2;
        var dx = centerX - cx, dy = centerY - cy;
        var dist = Math.sqrt(dx*dx + dy*dy);

        var radii = computeRadii(board);
        var droppedIn = false; var which = null;
        if (dist <= radii.rGreen)  { droppedIn = true; which = 'green'; }
        else if (dist <= radii.rOrange) { droppedIn = true; which = 'orange'; }
        else if (dist <= radii.rRed) { droppedIn = true; which = 'red'; }

        var dataId = el.getAttribute('data-id') || original.id.replace(/^tile-/, '');

        if (droppedIn) {
          // convert dragged element into a board item (absolute within board)
          var left = elRect.left - boardRect.left;
          var top  = elRect.top  - boardRect.top;
          el.classList.add('item');
          el.style.position = 'absolute';
          el.style.left = left + 'px';
          el.style.top  = top  + 'px';
          el.style.zIndex = '';
          el.style.pointerEvents = '';
          el.id = 'item-' + dataId;
          el.setAttribute('data-id', dataId);
          el.style.background = 'transparent';
          board.appendChild(el);
          // attach tooltip to placed item
          try { var label = (ITEMS.find(function(x){ return x.id===dataId; }) || {}).label || dataId; attachTooltip(el, label); } catch(e){}
          // set score for this item
          var scoreVal = (which === 'green') ? 1 : (which === 'orange') ? 2 : 3;
          setItemScore(dataId, scoreVal);
          clearRingHighlights();
          var ring = board.querySelector('.ring.' + which);
          if (ring) ring.classList.add('active');
        } else {
          // restore to placeholder slot
          try {
            el.classList.remove('item');
            el.style.position = '';
            el.style.left = '';
            el.style.top = '';
            el.style.width = '';
            el.style.height = '';
            el.style.pointerEvents = '';
            if (original.parent) {
              original.parent.appendChild(el);
            }
          } catch (err) { console.error('restore failed', err); }
          // clear score
          setItemScore(dataId, 0);
        }

        // cleanup
        dragEl.classList.remove('dragging');
        dragEl = null;
      }

      el.addEventListener('pointerdown', down);
    }

    function scoreFor (el, board) {
      var b = board.getBoundingClientRect();
      var cx = b.left + b.width/2, cy = b.top + b.height/2;

  var radii = computeRadii(board);

      var r = el.getBoundingClientRect();
      var ix = r.left + r.width/2, iy = r.top + r.height/2;
      var dx = ix - cx, dy = iy - cy;
      var dist = Math.sqrt(dx*dx + dy*dy);

      if (dist <= radii.rGreen)  return 1;   // green
      if (dist <= radii.rOrange) return 2;   // orange
      if (dist <= radii.rRed)    return 3;   // red
      return 0;                        // white
    }

    function collectPlacements () {
      var board = document.getElementById('board');
      var out = [];
      // If board is not present (jsPsych may have cleared DOM), fall back to SCORES and element rects
      if (!board) {
        ITEMS.forEach(function (it) {
          var el = document.getElementById('item-' + it.id);
          var score = (it.id in SCORES) ? SCORES[it.id] : (window[it.id + 'Score'] || 0);
          if (!el) {
            out.push({ id: it.id, label: it.label, x: -1, y: -1, score: score });
            return;
          }
          var r = el.getBoundingClientRect();
          out.push({ id: it.id, label: it.label, x: Math.round(r.left), y: Math.round(r.top), score: score });
        });
        return out;
      }

      var b = board.getBoundingClientRect();
      ITEMS.forEach(function (it) {
        var el = document.getElementById('item-' + it.id);
        if (!el) {
          // item not moved onto board -> treat as outside
          out.push({ id: it.id, label: it.label, x: -1, y: -1, score: 0 });
          return;
        }
        var s = scoreFor(el, board);
        var r = el.getBoundingClientRect();
        out.push({ id: it.id, label: it.label, x: Math.round(r.left - b.left), y: Math.round(r.top - b.top), score: s });
      });
      return out;
    }

    // Export scores and metadata to CSV and trigger a download
    // Modal preview helper (singleton)
    var kc_csv_modal = null;
    function ensureCsvModal() {
      if (kc_csv_modal) return kc_csv_modal;
      var modal = document.createElement('div');
      modal.id = 'kc-csv-modal';
  modal.style.position = 'fixed';
  modal.style.left = '0'; modal.style.top = '0'; modal.style.right = '0'; modal.style.bottom = '0';
  // start hidden; showCsvPreview will set display to 'flex' when needed
  modal.style.display = 'none'; modal.style.alignItems = 'center'; modal.style.justifyContent = 'center';
      modal.style.background = 'rgba(0,0,0,0.45)'; modal.style.zIndex = 200000;

      var box = document.createElement('div');
      box.style.background = '#fff'; box.style.color = '#000'; box.style.borderRadius = '8px'; box.style.padding = '16px'; box.style.maxWidth = '90%'; box.style.width = '760px'; box.style.maxHeight = '80%'; box.style.overflow = 'auto';

      var h = document.createElement('h3'); h.textContent = 'CSV preview'; box.appendChild(h);
      var pre = document.createElement('pre'); pre.id = 'kc-csv-preview'; pre.style.background = '#f6f6f6'; pre.style.padding = '10px'; pre.style.whiteSpace = 'pre-wrap'; pre.style.wordBreak = 'break-word'; pre.style.maxHeight = '60vh'; pre.style.overflow = 'auto'; box.appendChild(pre);

      var btnRow = document.createElement('div'); btnRow.style.display = 'flex'; btnRow.style.gap = '8px'; btnRow.style.marginTop = '12px'; btnRow.style.justifyContent = 'flex-end';
      var cancel = document.createElement('button'); cancel.textContent = 'Cancel'; cancel.className = 'jspsych-btn';
      var confirm = document.createElement('button'); confirm.textContent = 'Download CSV'; confirm.className = 'jspsych-btn';
      btnRow.appendChild(cancel); btnRow.appendChild(confirm); box.appendChild(btnRow);

      modal.appendChild(box);
      document.body.appendChild(modal);

      // actions will be set by showCsvPreview (we keep references for cleanup)
      kc_csv_modal = { modal: modal, pre: pre, cancel: cancel, confirm: confirm };
      return kc_csv_modal;
    }

    // Show CSV preview and require confirmation before downloading.
    // callback(downloaded:boolean) invoked after user action
    function showCsvPreview(csvText, filename, callback) {
      try {
        var m = ensureCsvModal();
        m.pre.textContent = csvText;
        var onClose = function(downloaded){
          try { m.modal.style.display = 'none'; } catch(_){}
          if (callback) callback(downloaded);
        };
        // ensure visible
        m.modal.style.display = 'flex';

        // remove previous handlers
        m.cancel.onclick = function(){ onClose(false); };
        m.confirm.onclick = function(){
          try {
            // trigger download
            var blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(function(){ document.body.removeChild(a); URL.revokeObjectURL(url); }, 1500);
          } catch (e) { console.error('download failed', e); }
          onClose(true);
        };
      } catch (e) { console.error('showCsvPreview failed', e); if (callback) callback(false); }
    }

    function exportScoresToCSV(participantId, scoresObj, total) {
      try {
        // helper to CSV-escape a value
        function esc(v) {
          if (v === null || v === undefined) return '';
          var s = String(v);
          if (s.indexOf(',') !== -1 || s.indexOf('\n') !== -1 || s.indexOf('"') !== -1) {
            return '"' + s.replace(/"/g, '""') + '"';
          }
          return s;
        }

        var headers = ['participantId'].concat(ITEMS.map(function(it){ return it.id; })).concat(['total','timestamp']);
        var row = [participantId || ''].concat(ITEMS.map(function(it){ return (it.id in scoresObj) ? scoresObj[it.id] : 0; })).concat([total || 0, new Date().toISOString()]);

        var csv = headers.map(esc).join(',') + '\n' + row.map(esc).join(',') + '\n';
        var safeId = (participantId && participantId.length) ? participantId.replace(/[^a-zA-Z0-9-_]/g,'') : 'unknown';
        var filename = 'kc_scores_' + safeId + '_' + Date.now() + '.csv';

        // show preview and only download if user confirms
        console.log('exportScoresToCSV: prepared CSV, showing preview for', filename);
        showCsvPreview(csv, filename, function(downloaded){
          if (!downloaded) {
            console.log('User cancelled CSV download (or preview failed) for', filename);
          } else {
            console.log('CSV downloaded:', filename);
          }
        });
      } catch (e) { console.error('exportScoresToCSV failed', e); }
    }

    // --- Debug panel (visible when DEBUG_PANEL_ENABLED is true) ---
  var DEBUG_PANEL_ENABLED = false;
    function ensureDebugPanel() {
      if (!DEBUG_PANEL_ENABLED) return null;
      var existing = document.getElementById('kc-debug-panel');
      if (existing) return existing;
      var p = document.createElement('div'); p.id = 'kc-debug-panel';
      p.style.position = 'fixed'; p.style.right = '12px'; p.style.bottom = '12px'; p.style.width = '300px'; p.style.maxHeight = '60vh';
      p.style.overflow = 'auto'; p.style.background = '#fff'; p.style.border = '1px solid #ccc'; p.style.borderRadius = '8px'; p.style.padding = '8px'; p.style.zIndex = 200001; p.style.fontSize = '12px';

      var title = document.createElement('div'); title.textContent = 'DEBUG'; title.style.fontWeight = '700'; title.style.marginBottom = '6px'; p.appendChild(title);
      var pid = document.createElement('div'); pid.id = 'kc-debug-pid'; p.appendChild(pid);
      var scoresPre = document.createElement('pre'); scoresPre.id = 'kc-debug-scores'; scoresPre.style.background = '#f6f6f6'; scoresPre.style.padding = '6px'; scoresPre.style.whiteSpace = 'pre-wrap'; scoresPre.style.maxHeight = '180px'; scoresPre.style.overflow = 'auto'; p.appendChild(scoresPre);
      var csvPreview = document.createElement('pre'); csvPreview.id = 'kc-debug-csv'; csvPreview.style.background = '#fffbe6'; csvPreview.style.padding = '6px'; csvPreview.style.whiteSpace = 'pre-wrap'; csvPreview.style.maxHeight = '180px'; csvPreview.style.overflow = 'auto'; p.appendChild(csvPreview);

      var btnRow = document.createElement('div'); btnRow.style.display = 'flex'; btnRow.style.gap = '6px'; btnRow.style.marginTop = '6px';
      var refresh = document.createElement('button'); refresh.textContent = 'Refresh'; refresh.className = 'jspsych-btn';
      var preview = document.createElement('button'); preview.textContent = 'Preview CSV'; preview.className = 'jspsych-btn';
      var download = document.createElement('button'); download.textContent = 'Download CSV'; download.className = 'jspsych-btn';
      btnRow.appendChild(refresh); btnRow.appendChild(preview); btnRow.appendChild(download); p.appendChild(btnRow);

      refresh.onclick = function(){ renderDebugPanel(); };
      preview.onclick = function(){ manualPreviewFromDebug(); };
      download.onclick = function(){ manualDownloadFromDebug(); };

      document.body.appendChild(p);
      renderDebugPanel();
      return p;
    }

    function renderDebugPanel() {
      try {
        var pidEl = document.getElementById('kc-debug-pid');
        var scoresEl = document.getElementById('kc-debug-scores');
        var csvEl = document.getElementById('kc-debug-csv');
        if (!pidEl) return;
        var pid = jsPsych && jsPsych.data ? (jsPsych.data.get().values().length ? jsPsych.data.get().select('participantId').values()[0] : jsPsych.data.getURLVariable('ParticipantID')) : '';
        pidEl.textContent = 'participantId: ' + (pid || '');
        scoresEl.textContent = JSON.stringify(SCORES, null, 2);
        // generate a tiny CSV preview
        try {
          var headers = ['participantId'].concat(ITEMS.map(function(it){ return it.id; })).concat(['total','timestamp']);
          var total = ITEMS.reduce(function(acc,it){ return acc + ((it.id in SCORES) ? SCORES[it.id] : 0); }, 0);
          var row = [pid || ''].concat(ITEMS.map(function(it){ return (it.id in SCORES) ? SCORES[it.id] : 0; })).concat([total || 0, new Date().toISOString()]);
          var csv = headers.join(',') + '\n' + row.join(',');
          csvEl.textContent = csv;
        } catch (e) { csvEl.textContent = 'csv preview error: ' + e.message; }
      } catch (e) { console.error('renderDebugPanel failed', e); }
    }

    function manualPreviewFromDebug() {
      try {
        var csv = document.getElementById('kc-debug-csv').textContent || '';
        var pid = jsPsych.data.get().select('participantId').values()[0] || jsPsych.data.getURLVariable('ParticipantID') || '';
        var filename = 'kc_scores_' + ((pid && pid.length) ? pid.replace(/[^a-zA-Z0-9-_]/g,'') : 'unknown') + '_' + Date.now() + '.csv';
        showCsvPreview(csv, filename, function(downloaded){ console.log('manual preview callback downloaded=', downloaded); });
      } catch (e) { console.error('manualPreviewFromDebug failed', e); }
    }

    function manualDownloadFromDebug() {
      try {
        var csv = document.getElementById('kc-debug-csv').textContent || '';
        var pid = jsPsych.data.get().select('participantId').values()[0] || jsPsych.data.getURLVariable('ParticipantID') || '';
        var safeId = (pid && pid.length) ? pid.replace(/[^a-zA-Z0-9-_]/g,'') : 'unknown';
        var filename = 'kc_scores_' + safeId + '_' + Date.now() + '.csv';
        var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        var url = URL.createObjectURL(blob); var a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(function(){ document.body.removeChild(a); URL.revokeObjectURL(url); }, 1500);
      } catch (e) { console.error('manualDownloadFromDebug failed', e); }
    }

    // Initialize debug panel after DOM ready
    try { if (document.readyState === 'complete' || document.readyState === 'interactive') { setTimeout(ensureDebugPanel, 50); } else { document.addEventListener('DOMContentLoaded', function(){ setTimeout(ensureDebugPanel, 50); }); } } catch (e) { console.error('init debug panel failed', e); }

    // POST results to a remote collector (Apps Script or server)
    function postResultsToServer(endpointUrl, secretToken, payload) {
      try {
        var body = Object.assign({}, payload);
        if (secretToken) body.secret = secretToken;
        // Use text/plain content-type to avoid a CORS preflight OPTIONS request.
        // Browsers only send a simple (non-preflighted) POST when Content-Type is
        // one of: application/x-www-form-urlencoded, multipart/form-data or text/plain.
        // Apps Script will still receive the raw JSON in e.postData.contents.
        return fetch(endpointUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: JSON.stringify(body)
        }).then(function(resp){
          // If the response is opaque due to no-cors or other issues, resp.ok may be falsey
          // but the request may have been delivered. We attempt to parse JSON, else return status.
          if (!resp.ok) {
            // try to get text body for debugging
            return resp.text().then(function(txt){
              var msg = 'HTTP ' + resp.status + ' - ' + txt;
              throw new Error(msg);
            }).catch(function(){ throw new Error('HTTP ' + resp.status); });
          }
          return resp.json().catch(function(){ return { status: 'ok' }; });
        }).then(function(j){
          console.log('postResultsToServer success', j);
          try { if (!window.KC_SUPPRESS_SHOWERROR) { showError('Remote POST successful: ' + (j && j.status ? JSON.stringify(j) : 'ok')); } } catch(e){}
          return j;
        }).catch(function(err){
          console.error('postResultsToServer failed', err);
          try { if (!window.KC_SUPPRESS_SHOWERROR) { showError('Remote POST failed: ' + (err && err.message ? err.message : String(err))); } } catch(e){}
          throw err;
        });
      } catch (e) { console.error('postResultsToServer exception', e); }
    }

    // Read the ParticipantID URL parameter and add it to jsPsych data properties.
    try {
      var participantId = (window.jsPsych && jsPsych.data && jsPsych.data.getURLVariable) ? jsPsych.data.getURLVariable('ParticipantID') : '';
      if (window.jsPsych && jsPsych.data && jsPsych.data.addProperties) {
        jsPsych.data.addProperties({ participantId: participantId });
      }
    } catch (e) { console.error('setting participantId failed', e); }
    // ======= INSTRUCTIONS =======
    var instructions = {
      type: 'html-button-response',
      stimulus:
        '<div style="max-width:820px">' +
          '<h2>In this game you will XXX</h2>' +
          '<audio id="kc-welcome-audio" preload="auto" controls="true" autoplay="true" style="width:100%;margin-top:8px">' +
            '<source type="audio/mp3" src="mp3/welcome.mp3">' +
            'Your browser does not support the audio element.' +
          '</audio>' +
          '<p style="margin-top:12px">When youâ€™re ready, click Continue.</p>' +
        '</div>',
      choices: ['I am ready!']
    };
    timeline.push(instructions);

    // ======= DRAG-AND-DROP TRIAL =======
    var place_items_trial = {
      type: 'html-button-response',
      stimulus: function () { return boardHTML(); },
      choices: ['I am done!'],
  // put the Continue button at the bottom center (default placement)
  button_html: '<button class="jspsych-btn">%choice%</button>',
  on_load: function () { try { console.log('place_items_trial on_load'); placeStartTiles();
          // disable Continue until all items are placed
          window.kc_monitor_interval = window.kc_monitor_interval || setInterval(function(){
            try {
              var btn = document.querySelector('#jspsych-target .jspsych-btn');
              var placed = document.querySelectorAll('#board .item').length;
              if (btn) {
                if (placed >= ITEMS.length) {
                  btn.disabled = false; btn.classList.remove('disabled'); btn.style.display = ''; 
                } else {
                  btn.disabled = true; btn.classList.add('disabled'); btn.style.display = 'none';
                }
              }
            } catch (e) { /* ignore */ }
          }, 200);
          // also disable immediately in case button is present now
          try { var _b = document.querySelector('#jspsych-target .jspsych-btn'); if (_b) { _b.disabled = true; _b.classList.add('disabled'); _b.style.display = 'none'; } } catch(e){}
        } catch (e) { console.error('Error in place_items_trial on_load', e); try { showError('place_items_trial on_load error: '+ e.message); } catch (ee){} } },
      on_finish: function (data) {
        try {
          console.log('Placement trial on_finish starting');
            var placements = jsPsych.data.get().filter({trial_type: 'place_items'}).values();
            var placement = placements && placements.length ? placements[placements.length-1] : null;
            // copyable block only
            var vars = [];
            ITEMS.forEach(function(it){ var val = (placement && placement.scores && (it.id in placement.scores)) ? placement.scores[it.id] : (SCORES[it.id]||0); vars.push(it.id + ': ' + val); });
            data.scores = {};
            var total = 0;
            vars.forEach(function(line) {
              var parts = line.split(': ');
              var id = parts[0];
              var score = parseInt(parts[1], 10);
              data.scores[id] = score;
              total += score;
            });
            data.total_score = total;
            console.log('Placement trial on_finish done', data);
        } catch (e) {
          console.error('Error in placement on_finish', e);
          try { showError('Placement on_finish error: ' + e.message); } catch (ee){}
        } finally {
          try { if (window.kc_monitor_interval) { clearInterval(window.kc_monitor_interval); window.kc_monitor_interval = null; } } catch(e){}
        }
      }
    };
    timeline.push(place_items_trial);

    // ======= SILENT SUBMIT (blocking) =======
    // Start the POST in a call-function trial, then push a waiting trial that
    // polls for completion. This blocks the timeline (and the enclosing iframe)
    // until the POST resolves (or a timeout elapses), which is useful when
    // embedding in Qualtrics so the survey doesn't advance before submission.
    var start_post = {
      type: 'call-function',
      func: function() {
        try {
          window.KC_SUBMIT_DONE = false;
          window.KC_SUBMIT_ERROR = null;
          var scoresObj = {};
          var total = 0;
          ITEMS.forEach(function(it){
            var s = (it.id in SCORES) ? SCORES[it.id] : (window[it.id + 'Score'] || 0);
            scoresObj[it.id] = s;
            total += (s||0);
          });
          var pid = (jsPsych && jsPsych.data && jsPsych.data.select) ? (jsPsych.data.get().select('participantId').values()[0] || jsPsych.data.getURLVariable('ParticipantID')) : (jsPsych && jsPsych.data ? jsPsych.data.getURLVariable('ParticipantID') : '');
          var endpoint = window.KC_REMOTE_ENDPOINT || '';
          var secret = window.KC_REMOTE_SECRET || '';
          var payload = { participantId: pid, item_ids: ITEMS.map(function(it){ return it.id; }), scores: scoresObj, total: total };
          if (!endpoint) {
            console.warn('Silent submit: KC_REMOTE_ENDPOINT not set; skipping remote POST');
            window.KC_SUBMIT_DONE = true;
            return;
          }
          // suppress visible status box during iframe/Qualtrics submission
          window.KC_SUPPRESS_SHOWERROR = true;
          console.log('Submitting results to remote...');
          postResultsToServer(endpoint, secret, payload).then(function(res){
            window.KC_SUBMIT_DONE = true; window.KC_SUBMIT_ERROR = null; 
            window.KC_SUPPRESS_SHOWERROR = false;
            console.log('Submission finished.');
            // notify parent (Qualtrics iframe) that submission completed
            try {
              if (window.parent && window.parent !== window) {
                window.parent.postMessage({ kc_submit: true, participantId: pid, result: res }, '*');
                // Also send a 'gamecomplete' message so Qualtrics can hide/disable its "Next" button
                window.parent.postMessage({ type: 'gamecomplete', participantId: pid, timing_ms: 3000 }, '*');
                window.KC_POSTED_TO_PARENT = true;
              }
            } catch (e) { console.error('postMessage to parent failed', e); }
          }).catch(function(err){
            window.KC_SUBMIT_DONE = true; window.KC_SUBMIT_ERROR = (err && err.message) ? err.message : String(err);
            window.KC_SUPPRESS_SHOWERROR = false;
            console.error('Submission failed: ' + window.KC_SUBMIT_ERROR);
            // still attempt to notify parent of failure
            try {
              if (window.parent && window.parent !== window) {
                window.parent.postMessage({ kc_submit: false, participantId: pid, error: window.KC_SUBMIT_ERROR }, '*');
                // Inform parent that game is complete (but errored); parent can choose
                // to reveal its Next button after a delay or show an error UI.
                window.parent.postMessage({ type: 'gamecomplete', participantId: pid, timing_ms: 3000, error: window.KC_SUBMIT_ERROR }, '*');
                window.KC_POSTED_TO_PARENT = true;
              }
            } catch (e) { console.error('postMessage to parent failed', e); }
          });
        } catch (e) { console.error('start_post failed', e); window.KC_SUBMIT_DONE = true; window.KC_SUBMIT_ERROR = e && e.message ? e.message : String(e); }
      }
    };
    timeline.push(start_post);

    var wait_for_submit = {
      type: 'html-keyboard-response',
      stimulus: '<div style="max-width:820px">' +
                 '<audio width="320" preload="auto" height="40" controls="true" class="qmedia" autoplay="true">' +
                   '<source type="audio/mp3" src="mp3/complete.mp3">' +
                 '</audio>' +
                 '<div style="margin-top:12px;font-weight:600;">Hooray! You\'ve finished the activity!</div>' +
               '</div>',
      choices: [],
      on_load: function() {
        try {
          var start = Date.now();
          var timeout = 20000; // ms
          var iv = setInterval(function(){
            try {
              if (window.KC_SUBMIT_DONE) {
                clearInterval(iv);
                // if there was an error, keep the message visible via showError
                setTimeout(function(){ try { jsPsych.finishTrial(); } catch(e){ console.error('finishTrial failed', e); } }, 200);
                return;
              }
              if (Date.now() - start > timeout) {
                clearInterval(iv);
                try { showError('Submission timed out after ' + (timeout/1000) + 's â€” continuing.'); } catch(e){}
                try { jsPsych.finishTrial(); } catch(e){ console.error('finishTrial after timeout failed', e); }
                return;
              }
            } catch (e) { console.error('wait_for_submit interval error', e); }
          }, 200);
        } catch (e) { console.error('wait_for_submit on_load error', e); }
      }
    };
    timeline.push(wait_for_submit);

    // ======= FINAL THANK YOU + AUDIO =======
    var final_thanks = {
      type: 'html-keyboard-response',
      stimulus: function() {
        return '' +
          '<div>' +
            '<audio width="320" preload="auto" height="40" controls="true" class="qmedia" autoplay="true">' +
              '<source type="audio/mp3" src="mp3/complete.mp3">' +
            '</audio>' +
            '<div style="margin-top:12px;font-weight:600;">Hooray! You\'ve finished the activity!</div>' +
            '<div>Well done!</div>' +
          '</div>';
      },
      choices: [],
      on_load: function() {
        try {
          // notify parent frame (Qualtrics) that the iframe is ready to continue
          var pid = (jsPsych && jsPsych.data && jsPsych.data.select) ? (jsPsych.data.get().select('participantId').values()[0] || jsPsych.data.getURLVariable('ParticipantID')) : (jsPsych && jsPsych.data ? jsPsych.data.getURLVariable('ParticipantID') : '');
          try {
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ kc_ready_to_continue: true, participantId: pid }, '*');
              window.KC_POSTED_READY = true;
            }
          } catch (e) { console.error('postMessage to parent (ready) failed', e); }
        } catch (e) { console.error('final_thanks on_load failed', e); }
      }
    };
    timeline.push(final_thanks);

    // ...existing code...

    // ======= INIT =======
    try {
      jsPsych.init({
        display_element: 'jspsych-target',
        timeline: timeline,
        default_iti: 0,
        auto_preload: false
      });
    } catch (e) {
      console.error('jsPsych.init error', e);
      try { showError('jsPsych.init error: ' + e.message); } catch (ee){}
    }
    </script>
  </body>
</html>
